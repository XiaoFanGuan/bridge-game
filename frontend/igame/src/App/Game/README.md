## 当前进度

  看一下 react-motion,已经看过了。比较清晰。

  修改打牌程序 解决跨域问题。

  获得了中心点坐标。

  考虑 game 和 Table 直接用 context 专递

  考虑是否可以调整  card 使得牌 横竖摆放坐标容易计算。
  考虑把 尺寸计算 写在单独的函数里。需要计算 四个区域的宽高比例。
  以及牌的大小。将来可以考虑保存客户端这些数据，不需要重复计算。

  考虑每张牌是从哪里打出来的？
  一墩牌 ：在哪里记录上一轮牌。

   这篇文章必须看：https://segmentfault.com/a/1190000005159165#articleHeader0

  明手的处理
  
  ：叫牌结果 显示。
  : 东南西北显示，用户显示。writing-mode:vertical-lr
：上以盾牌。

todo：登录
todo:扑克的位置计算：
todo：庄家显示。
todo：事件监听机制。
todo: claim


## 核心分析

经过分析，游戏环节只解决 一局比赛即可。其他如：多付牌，多个桌子等都可以用web 的方式来实现。游戏模块，只解决一局游戏即可。

注意考虑 ui 组件 和 普通控制 class 的区别。

react 主要完成界面的 设计规划。每个界面元素。
另外设计类和对象。完成游戏的控制部分。这和传统js 没有本质区别。

最外层是游戏的控制部分。

数据接口：
  监控监听通道。如果有了数据就进行数据的指派 分配调用对应的处理过程。


*** 根据后端逻辑，写出前端逻辑。然后排除游戏逻辑，写前端代码。
    仍然先用 聊天方式 完成所有界面。 完成严格打牌过程。
    主要目的：完成 react 的 控制模块。 其他Ui 模块可以再写。
    并且可以进行功能拆分了。

game 可以是纯 类。
Table 是一桌比赛 是 react 组件。
  一桌比赛可以有几个阶段。每个阶段都通过 条件渲染 来进行渲染。
  进入每个阶段。通过修改 table 的 state 来完成。

*** 再尝试条件渲染的方式。 一种是 setState 另外一种尝试是 动态挂在不同的组件在某个位置。

## 出牌动画 设计
  貌似 ant-motion  比 react-motion 更加简单一些。

  桌子上有一个方法是“出牌” 参数 某一张牌。 然后调用 牌的 setState() 修改他的默认位置。
  涉及到 父组件修改子组件的位置。因此：
  生成每一张牌的时候。把父对象以 属性的方式 传递到 子组件里。
  子组件里 把 setState 相关方法，添加到 父对象的出牌方法上。
  这样父对象执行 出牌方法，则会触发子组件的 setState

  注意 TweenOne 动画，就是x,y 是移动量，top,left 是定位。因此应该用 top,left
  结合 style 属性。style 就是元素的演示，如果元素样式定义了 top,left 和上面一样，则不动。

## 关于界面布局

  可以考虑 游戏逻辑是游戏逻辑。而所有的界面都可以制作成纯UI 组件。
  这样可以随时进行界面的更新调整。

  可以按照以下思路进行抽象： 
    划分若干区域，这些区域都是明确不变的。考虑扑克规则无关。
    这些区域渲染什么 ui 组件，由程序动态获得。
    或者 指定。如果需要其他，则简单修改配置文件。

## 关于css 
  原本考虑都写在 style 里面写成变量。但这样不能很好的利用 css 应用多个 类选择器的特性。
  因此最终考虑：先都写在 css 里面。然后那些发生变化的属性，再提取出来写在style里面。  

## 结构分析

  game      最外层，记录本次游戏的相关信息。 比如判断登录等等。
    table     游戏界面的桌子

## 游戏流程和数据 （后端）

1. test() -> process_one_table(t) 循环处理每一张桌子。->
    listen_users_login(t1) 监听用户登录-> 处理每一副牌。
    play_game(t1, b)

2. play_game 向每个玩家发牌 red.publish('chat','SERVER(N):%s' % bd.deal['N')
   user, call = listen_bid(tbl,bd)
   如果 d.contract 开始 首攻阶段。
   出牌阶段
      如果 是 play 就是打牌。
      如果是 claim 进行处理。
      claim 进入 claim 阶段，选择是否同意。

## 游戏流程和数据 （前端）考虑避免涉及游戏逻辑
1. 登录  
2. 坐下 ready
3. 都坐下后
4. 发牌


## Card 牌
  <Card name="D5">
  花色，点数
  正反
  



## 牌桌
  几个方位。
  方位：东南西北，或者斗地主3个位置。

## 玩家



## 一局比赛：board
  上一墩牌


## 一桌比赛：
  一桌比赛有多局

## 规则：
  不同游戏，有不同的规则，抽取规则的细节。考虑用什么设计模式。
  游戏名称

  几个玩家
  分几个阶段

  发牌规则
  出牌规则（能出，不能出）
  其他规则


## 其他细节。

  1）一个组件一个组件开发。每个组件应该有 “激活状态”和锁定状态， 对应用户可以操作，以及不能操作。把组件尽量做的 解耦。这样方便程序框架的搭建。
    比如 叫牌组件。输入：就是一个界面，输出，就是一个字符串


----------------------------------------

目录结构：
包含：
核心规则无关：
    ui  界面相关
    model 访问接口数据
    game 游戏控制
        settings.js

规则相关：
    rule 负责游戏规则（不同游戏）一个规则一个目录。
        bridge
          component 规则相关组件。
        doudizhu
        拱猪
    